\documentclass[13pt]{article}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{amsmath}
\usepackage{geometry}
\geometry{a4paper, portrait, margin=1in}


\title{ \vspace{-1cm}
	CP Algorithms Handbook}
\author{Stanisław Fiedler}
\date{\today}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=4
}

\lstset{style=mystyle}

\begin{document}
\maketitle
\tableofcontents
\pagebreak


\section{Sorting and Searching}

\subsection{Quick Sort}\label{sub:quick_sort} % (fold)
\lstinputlisting[language=c++, firstline=24, lastline=43]{code_snippets/sort}
\subsection{Merge Sort}\label{sub:merge_sort} % (fold)
\lstinputlisting[language=c++, firstline=1, lastline=21]{code_snippets/sort}

% subsection Merge Sort (end)

% subsection Quick Sort (end)

\section{Dynamic Programming}

\subsection{State represenation}\label{sub:state_represenation} % (fold)

\subsubsection{All subsets}\label{ssub:all_subsets} % (fold)
This way you can generate all subsets in order ready for DP.
\lstinputlisting[language=C++, firstline=1, lastline=5]{code_snippets/dp_states}
% subsubsection All subsets (end)

% subsection State represenation (end)

\pagebreak

\section{Graph Algorithms}

\subsection{Shortest Path}\label{sub:shortest_path} % (fold)
\subsubsection{Djikstra}
\lstinputlisting[language=C++, firstline=1, lastline=17]{code_snippets/shortest_path}
\subsubsection{Belman-Ford}
\lstinputlisting[language=C++, firstline=43, lastline=62]{code_snippets/shortest_path}
\subsubsection{Floyd–Warshal}
\lstinputlisting[language=C++, firstline=19, lastline=41]{code_snippets/shortest_path}
% subsection Shortest Path (end)

\subsection{Union Find}\label{sub:union_find} % (fold)
\lstinputlisting[language=C++, firstline=7, lastline=51]{code_snippets/union_find}
% subsection Union Find (end)

\subsection{Path through all edges}\label{sub:} % (fold)
\lstinputlisting[language=C++, firstline=1, lastline=67]{code_snippets/euleran_apth}
% subsection  (end)



\subsection{Topo Sort}\label{sub:topo_sort} % (fold)
\lstinputlisting[language=C++, firstline=7, lastline=50]{code_snippets/topo_sort}
% subsection Topo Sort (end)

\subsection{Flows and Cuts}
All problems in this section can be solved using the same basic algorithm defined in \ref{sec:MAXFLOW}.

\subsubsection{Maximum Flow}
\label{sec:MAXFLOW}
This implementation of Ford-Fulkerson algorithm (known as Edmonds-Karp algorithm) uses BFS to check if it's possible to expand the flow through the graph and assign depths from the source. Later it uses DFS to expand te flow.
\lstinputlisting[language=C++, firstline=11, lastline=66]{code_snippets/max_flow}

To find the flow:
\lstinputlisting[language=C++, firstline=89, lastline=97]{code_snippets/max_flow}

\subsubsection{Minimum Cut}
To find Minimum Cut in a graph we need to find the Maximum Flow and check which edges connect two created disjont sets of nodes. This modification to finds them:
\lstinputlisting[language=C++, firstline=92, lastline=116]{code_snippets/min_cut}
\subsubsection{Maximum Matching}

\subsection{2SAT}

Given logical formula in the conjunctive normal form:
\[ (a_1 \vee b_1) \wedge  (a_2 \vee b_2) \wedge ... \wedge (a_{n} \vee b_{n})\]
we can eliminate disjunction by repacing each \( (a_i \vee b_i) \) element with pair:
\[ \neg a_i \rightarrow b_i \wedge \neg b_i \rightarrow a_i \]

\lstinputlisting[language=C++, firstline=9, lastline=122]{code_snippets/2sat}

\section{Range Queries}

\subsection{Segment trees}

BASE size table:
\begin{center}
	\begin{tabular}{ c || c | c | c }
		a          & \(2 \cdot 10^5\) & \(5 \cdot 10^5\) & \(10^6\) \\
		\hline\hline
		\(log_2a\) & 18               & 19               & 20
	\end{tabular}
\end{center}

\subsubsection{Point-Range Trees}
\lstinputlisting[language=C++, firstline=83,lastline=109]{code_snippets/segment_trees}

\subsubsection{Range-Range Trees}
\begin{enumerate}
	\item range ADD insert, range MAX value query
	      \lstinputlisting[language=C++, firstline=1,lastline=20]{code_snippets/segment_trees}
	      \lstinputlisting[language=C++, firstline=22,lastline=39]{code_snippets/segment_trees}
	\item range ADD insert, range SUM qyerry
	      \lstinputlisting[language=C++, firstline=41,lastline=63]{code_snippets/segment_trees}
	      \lstinputlisting[language=C++, firstline=65,lastline=83]{code_snippets/segment_trees}
\end{enumerate}



\subsection{Max Subarray Sum}\label{sub:max_subarray_sum} % (fold)
\lstinputlisting[language=C++, firstline=1,lastline=22]{code_snippets/max_subarray}
% subsection Max Subarray Sum (end)

\section{Tree Algorithms}

\subsection{Binary Lifitng}\label{sub:binary_lifitng} % (fold)
\lstinputlisting[language=C++, firstline=24, lastline=35]{code_snippets/trees}
% subsection Binary Lifitng (end)

\subsection{Tree Traversal}\label{sub:tree_traversal} % (fold)
\lstinputlisting[language=C++, firstline=1, lastline=16]{code_snippets/trees}
% subsection Tree Traversal (end)

\subsection{LCA}\label{sub:lca} % (fold)
LCA can be found using binary lifting or by building a segment tree build on pre- and postorder.
% subsection LCA (end)


\section{String Algorithms}

\subsection{Trie}\label{sub:trie} % (fold)
\lstinputlisting[language=C++, firstline=9, lastline=34]{code_snippets/trie}
% subsection Trie (end)

\subsection{Pattern Finding}\label{sub:pattern_finding} % (fold)

\subsubsection{KMP}\label{ssub:kmp} % (fold)
\lstinputlisting[language=C++, firstline=7, lastline=29]{code_snippets/strings}
% subsubsection KMP (end)

\subsubsection{Hashing}\label{ssub:hashing} % (fold)

\lstinputlisting[language=C++, firstline=37, lastline=72]{code_snippets/strings}
% subsubsection Hashing (end)

% subsection Pattern Finding (end)

\pagebreak

\subsection{Palindormes}\label{sub:pal} % (fold)
Fiding longest palindromic substring.
\lstinputlisting[language=C++, firstline=75, lastline=107]{code_snippets/strings}
% subsection Trie (end)

\section{Mathematics}

\subsection{Fermat's Theorem}\label{sub:fermat_s_theorem} % (fold)
Modular inverse:
\[
	\text{If m is prime, then: } \Huge x^{-1}\,mod\,m = x^{m-2}\,mod\,m
\]
\[
	\Huge	x^{\varphi(m)}\,mod\,m = x^{k\,mod\,(m-1)}\,mod\,m
\]
\lstinputlisting[language=C++, firstline=7, lastline=15]{code_snippets/math}
% subsection Fermat's Theorem (end)

\subsection{Fast Fibonacci}\label{sub:fast_fibonacci} % (fold)
\lstinputlisting[language=C++, firstline=39, lastline=74]{code_snippets/math}
% subsection Fast Fibonacci (end)

\section{Geometry}

\subsection{Nie wiem co to robi}\label{sub:nie_wiem_co_to_robi} % (fold)
\lstinputlisting[language=C++, firstline=1, lastline=53]{code_snippets/point}
% subsection Nie wiem co to robi (end)

% section Geometry (end)

\section{Other Algorithms}


%--/Paper--

\end{document}
