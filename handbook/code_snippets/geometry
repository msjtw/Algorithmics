ll cross2(pii a, pii b) {
    return (ll)a.first * b.second - (ll)a.second * b.first;
}

int cross3(pii a, pii b, pii c){
    pii va, vb;
    va.first = b.first-a.first;
    va.second = b.second-a.second;
    vb.first = c.first-b.first;
    vb.second = c.second-b.second;
    return sign((ll)va.first*vb.second - (ll)vb.first*va.second);
}

sort(points.begin(), points.end(), [](pii l, pii r){
    int o = cross3(l, r, p0);
    if (o == 0) {
        return norm(sub(p0,l)) < norm(sub(p0,r));
    }
    return o < 0;
});

vector<pii> hull;

for (int i = 0; i < n; i++){
    while(hull.size() > 1 && cross3(hull[hull.size()-2], hull[hull.size()-1], points[i]) >= 0){
        hull.pop_back();
    }
    hull.push_back(points[i]);
}


int cross(pii a, pii b, pii c){
    pii va, vb;
    va.first = b.first-a.first;
    va.second = b.second-a.second;
    vb.first = c.first-b.first;
    vb.second = c.second-b.second;
    return sign((ll)va.first*vb.second - (ll)vb.first*va.second);
}

ll cros = cross(a, b, p);
if(cros > 0)
    cout << "LEFT\n";
else if(cros == 0)
    cout << "TOUCH\n";
else
    cout << "RIGHT\n";


int inter(pii a, pii b, pii c, pii d){
    pii p1 = {min(a.first, b.first), max(a.second, b.second)};
    pii p2 = {max(a.first, b.first), min(a.second, b.second)};
    pii p3 = {min(c.first, d.first), max(c.second, d.second)};
    pii p4 = {max(c.first, d.first), min(c.second, d.second)};

    if (p3.first > p2.first || p4.first < p1.first || p3.second < p2.second || p4.second > p1.second)
        return 0;

    if (sign(cross(a,b,c)) * sign(cross(a,b,d)) <= 0 && sign(cross(c,d,a)) * sign(cross(c,d,b)) <= 0) {
        return 1;
    }

    return 0;
}

bool point_on_line(pii a, pii b, pii p){
    int c = cross(a, b ,p);
    pii ld = {min(a.first, b.first), min(a.second, b.second)};
    pii pg = {max(a.first, b.first), max(a.second, b.second)};
    if(c == 0){
        if(!(p.first < ld.first || p.second < ld.second || p.first > pg.first || p.second > pg.second))
            return true;
    }
    return false;
}

int count = 0;
bool boundary = false;
for(int i = 0; i < n; i++){
    if (point_on_line(polygon[i], polygon[(i == n-1 ? 0 : i+1)], p)){
        boundary = true;
    }
    if (point_on_line(p, out, polygon[i])){
        if(cross(p, out, polygon[(i == 0 ? n-1 : i-1)]) * cross(p, out,polygon[(i == n-1 ? 0 : i+1)]) < 0){
            count --;
        }
    }
    count += inter(p, out, polygon[i], polygon[(i == n-1 ? 0 : i+1)]);
}

if (boundary){
    cout << "BOUNDARY" << endl;
}
else if (count & 1){
    cout << "INSIDE" << endl;
}
else {
    cout << "OUTSIDE" << endl;
}
